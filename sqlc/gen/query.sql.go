// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package palisade_database

import (
	"context"
	"time"
)

const getCoinInfo = `-- name: GetCoinInfo :one
SELECT id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade FROM coins
WHERE symbol = $1 LIMIT 1
`

func (q *Queries) GetCoinInfo(ctx context.Context, symbol string) (Coin, error) {
	row := q.db.QueryRow(ctx, getCoinInfo, symbol)
	var i Coin
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Symbol,
		&i.Status,
		&i.Baseasset,
		&i.Baseassetprecision,
		&i.Quoteasset,
		&i.Quoteprecision,
		&i.Quoteassetprecision,
		&i.Basecommissionprecision,
		&i.Quotecommissionprecision,
		&i.Ordertypes,
		&i.Isspottradingallowed,
		&i.Ismargintradingallowed,
		&i.Quoteamountprecision,
		&i.Basesizeprecision,
		&i.Permissions,
		&i.Maxquoteamount,
		&i.Makercommission,
		&i.Takercommission,
		&i.Quoteamountprecisionmarket,
		&i.Maxquoteamountmarket,
		&i.Fullname,
		&i.Tradesidetype,
		&i.Ispalisade,
	)
	return i, err
}

const getCoinState = `-- name: GetCoinState :one
SELECT id, date, account_balance, coinfirst, coinsecond, price, amount, state, orderid, uplevel, downlevel FROM state
WHERE coinFirst = $1 AND coinSecond = $2 LIMIT 1
`

type GetCoinStateParams struct {
	Coinfirst  string
	Coinsecond string
}

func (q *Queries) GetCoinState(ctx context.Context, arg GetCoinStateParams) (State, error) {
	row := q.db.QueryRow(ctx, getCoinState, arg.Coinfirst, arg.Coinsecond)
	var i State
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.AccountBalance,
		&i.Coinfirst,
		&i.Coinsecond,
		&i.Price,
		&i.Amount,
		&i.State,
		&i.Orderid,
		&i.Uplevel,
		&i.Downlevel,
	)
	return i, err
}

const getCountLogsByCoin = `-- name: GetCountLogsByCoin :one
SELECT COUNT(*) FROM logs
WHERE coinFirst = $1 AND coinSecond = $2 LIMIT 1
`

type GetCountLogsByCoinParams struct {
	Coinfirst  string
	Coinsecond string
}

func (q *Queries) GetCountLogsByCoin(ctx context.Context, arg GetCountLogsByCoinParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountLogsByCoin, arg.Coinfirst, arg.Coinsecond)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const saveCoin = `-- name: SaveCoin :one
INSERT INTO
    coins (
    date,
    symbol,
    status,
    baseAsset,
    baseAssetPrecision,
    quoteAsset,
    quotePrecision,
    quoteAssetPrecision,
    baseCommissionPrecision,
    quoteCommissionPrecision,
    orderTypes,
    isSpotTradingAllowed,
    isMarginTradingAllowed,
    quoteAmountPrecision,
    baseSizePrecision,
    permissions,
    maxQuoteAmount,
    makerCommission,
    takerCommission,
    quoteAmountPrecisionMarket,
    maxQuoteAmountMarket,
    fullName,
    tradeSideType,
    isPalisade
)
VALUES (
           $1,
           $2,
           $3,
           $4,
           $5,
           $6,
           $7,
           $8,
           $9,
           $10,
           $11,
           $12,
           $13,
           $14,
           $15,
           $16,
           $17,
           $18,
           $19,
           $20,
           $21,
           $22,
           $23,
           $24
       )
    RETURNING id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade
`

type SaveCoinParams struct {
	Date                       time.Time
	Symbol                     string
	Status                     int
	Baseasset                  string
	Baseassetprecision         float64
	Quoteasset                 string
	Quoteprecision             int
	Quoteassetprecision        int
	Basecommissionprecision    int
	Quotecommissionprecision   int
	Ordertypes                 []string
	Isspottradingallowed       bool
	Ismargintradingallowed     bool
	Quoteamountprecision       float64
	Basesizeprecision          float64
	Permissions                []string
	Maxquoteamount             int
	Makercommission            float64
	Takercommission            float64
	Quoteamountprecisionmarket float64
	Maxquoteamountmarket       int
	Fullname                   string
	Tradesidetype              int
	Ispalisade                 bool
}

func (q *Queries) SaveCoin(ctx context.Context, arg SaveCoinParams) (Coin, error) {
	row := q.db.QueryRow(ctx, saveCoin,
		arg.Date,
		arg.Symbol,
		arg.Status,
		arg.Baseasset,
		arg.Baseassetprecision,
		arg.Quoteasset,
		arg.Quoteprecision,
		arg.Quoteassetprecision,
		arg.Basecommissionprecision,
		arg.Quotecommissionprecision,
		arg.Ordertypes,
		arg.Isspottradingallowed,
		arg.Ismargintradingallowed,
		arg.Quoteamountprecision,
		arg.Basesizeprecision,
		arg.Permissions,
		arg.Maxquoteamount,
		arg.Makercommission,
		arg.Takercommission,
		arg.Quoteamountprecisionmarket,
		arg.Maxquoteamountmarket,
		arg.Fullname,
		arg.Tradesidetype,
		arg.Ispalisade,
	)
	var i Coin
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Symbol,
		&i.Status,
		&i.Baseasset,
		&i.Baseassetprecision,
		&i.Quoteasset,
		&i.Quoteprecision,
		&i.Quoteassetprecision,
		&i.Basecommissionprecision,
		&i.Quotecommissionprecision,
		&i.Ordertypes,
		&i.Isspottradingallowed,
		&i.Ismargintradingallowed,
		&i.Quoteamountprecision,
		&i.Basesizeprecision,
		&i.Permissions,
		&i.Maxquoteamount,
		&i.Makercommission,
		&i.Takercommission,
		&i.Quoteamountprecisionmarket,
		&i.Maxquoteamountmarket,
		&i.Fullname,
		&i.Tradesidetype,
		&i.Ispalisade,
	)
	return i, err
}
