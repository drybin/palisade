// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package palisade_database

import (
	"context"
	"time"
)

const getCoinInfo = `-- name: GetCoinInfo :one
SELECT id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade, lastcheck, support, resistance, rangevalue, rangepercent, avgprice, volatility, maxdrawdown, maxrise FROM coins
WHERE symbol = $1 LIMIT 1
`

func (q *Queries) GetCoinInfo(ctx context.Context, symbol string) (Coin, error) {
	row := q.db.QueryRow(ctx, getCoinInfo, symbol)
	var i Coin
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Symbol,
		&i.Status,
		&i.Baseasset,
		&i.Baseassetprecision,
		&i.Quoteasset,
		&i.Quoteprecision,
		&i.Quoteassetprecision,
		&i.Basecommissionprecision,
		&i.Quotecommissionprecision,
		&i.Ordertypes,
		&i.Isspottradingallowed,
		&i.Ismargintradingallowed,
		&i.Quoteamountprecision,
		&i.Basesizeprecision,
		&i.Permissions,
		&i.Maxquoteamount,
		&i.Makercommission,
		&i.Takercommission,
		&i.Quoteamountprecisionmarket,
		&i.Maxquoteamountmarket,
		&i.Fullname,
		&i.Tradesidetype,
		&i.Ispalisade,
		&i.Lastcheck,
		&i.Support,
		&i.Resistance,
		&i.Rangevalue,
		&i.Rangepercent,
		&i.Avgprice,
		&i.Volatility,
		&i.Maxdrawdown,
		&i.Maxrise,
	)
	return i, err
}

const getCoinState = `-- name: GetCoinState :one
SELECT id, date, account_balance, coinfirst, coinsecond, price, amount, state, orderid, uplevel, downlevel FROM state
WHERE coinFirst = $1 AND coinSecond = $2 LIMIT 1
`

type GetCoinStateParams struct {
	Coinfirst  string
	Coinsecond string
}

func (q *Queries) GetCoinState(ctx context.Context, arg GetCoinStateParams) (State, error) {
	row := q.db.QueryRow(ctx, getCoinState, arg.Coinfirst, arg.Coinsecond)
	var i State
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.AccountBalance,
		&i.Coinfirst,
		&i.Coinsecond,
		&i.Price,
		&i.Amount,
		&i.State,
		&i.Orderid,
		&i.Uplevel,
		&i.Downlevel,
	)
	return i, err
}

const getCoins = `-- name: GetCoins :many
SELECT id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade, lastcheck, support, resistance, rangevalue, rangepercent, avgprice, volatility, maxdrawdown, maxrise FROM coins
WHERE 
    ($3::boolean IS NULL OR isSpotTradingAllowed = $3)
    AND ($4::boolean IS NULL OR isPalisade = $4)
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetCoinsParams struct {
	Limit   int32
	Offset  int32
	Column3 bool
	Column4 bool
}

func (q *Queries) GetCoins(ctx context.Context, arg GetCoinsParams) ([]Coin, error) {
	rows, err := q.db.Query(ctx, getCoins,
		arg.Limit,
		arg.Offset,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Coin
	for rows.Next() {
		var i Coin
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Symbol,
			&i.Status,
			&i.Baseasset,
			&i.Baseassetprecision,
			&i.Quoteasset,
			&i.Quoteprecision,
			&i.Quoteassetprecision,
			&i.Basecommissionprecision,
			&i.Quotecommissionprecision,
			&i.Ordertypes,
			&i.Isspottradingallowed,
			&i.Ismargintradingallowed,
			&i.Quoteamountprecision,
			&i.Basesizeprecision,
			&i.Permissions,
			&i.Maxquoteamount,
			&i.Makercommission,
			&i.Takercommission,
			&i.Quoteamountprecisionmarket,
			&i.Maxquoteamountmarket,
			&i.Fullname,
			&i.Tradesidetype,
			&i.Ispalisade,
			&i.Lastcheck,
			&i.Support,
			&i.Resistance,
			&i.Rangevalue,
			&i.Rangepercent,
			&i.Avgprice,
			&i.Volatility,
			&i.Maxdrawdown,
			&i.Maxrise,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoinsToProcess = `-- name: GetCoinsToProcess :many
SELECT id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade, lastcheck, support, resistance, rangevalue, rangepercent, avgprice, volatility, maxdrawdown, maxrise FROM coins
WHERE 
    isSpotTradingAllowed = true
    AND isPalisade = true
    AND volatility > 0.2
    AND volatility < 0.5
    AND quoteasset = 'USDT'
ORDER BY lastcheck DESC
LIMIT $1
OFFSET $2
`

type GetCoinsToProcessParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetCoinsToProcess(ctx context.Context, arg GetCoinsToProcessParams) ([]Coin, error) {
	rows, err := q.db.Query(ctx, getCoinsToProcess, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Coin
	for rows.Next() {
		var i Coin
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Symbol,
			&i.Status,
			&i.Baseasset,
			&i.Baseassetprecision,
			&i.Quoteasset,
			&i.Quoteprecision,
			&i.Quoteassetprecision,
			&i.Basecommissionprecision,
			&i.Quotecommissionprecision,
			&i.Ordertypes,
			&i.Isspottradingallowed,
			&i.Ismargintradingallowed,
			&i.Quoteamountprecision,
			&i.Basesizeprecision,
			&i.Permissions,
			&i.Maxquoteamount,
			&i.Makercommission,
			&i.Takercommission,
			&i.Quoteamountprecisionmarket,
			&i.Maxquoteamountmarket,
			&i.Fullname,
			&i.Tradesidetype,
			&i.Ispalisade,
			&i.Lastcheck,
			&i.Support,
			&i.Resistance,
			&i.Rangevalue,
			&i.Rangepercent,
			&i.Avgprice,
			&i.Volatility,
			&i.Maxdrawdown,
			&i.Maxrise,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoinsToProcessTPTU = `-- name: GetCoinsToProcessTPTU :many
SELECT id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade, lastcheck, support, resistance, rangevalue, rangepercent, avgprice, volatility, maxdrawdown, maxrise FROM coins
WHERE 
    isSpotTradingAllowed = true
    AND isPalisade = true
    --AND volatility > 0.1
    --AND volatility < 0.4
    AND quoteasset = 'USDT'
    --AND symbol = 'TPTUUSDT'
    AND symbol = 'LTCUSDT'
ORDER BY lastcheck DESC
LIMIT $1
OFFSET $2
`

type GetCoinsToProcessTPTUParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetCoinsToProcessTPTU(ctx context.Context, arg GetCoinsToProcessTPTUParams) ([]Coin, error) {
	rows, err := q.db.Query(ctx, getCoinsToProcessTPTU, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Coin
	for rows.Next() {
		var i Coin
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Symbol,
			&i.Status,
			&i.Baseasset,
			&i.Baseassetprecision,
			&i.Quoteasset,
			&i.Quoteprecision,
			&i.Quoteassetprecision,
			&i.Basecommissionprecision,
			&i.Quotecommissionprecision,
			&i.Ordertypes,
			&i.Isspottradingallowed,
			&i.Ismargintradingallowed,
			&i.Quoteamountprecision,
			&i.Basesizeprecision,
			&i.Permissions,
			&i.Maxquoteamount,
			&i.Makercommission,
			&i.Takercommission,
			&i.Quoteamountprecisionmarket,
			&i.Maxquoteamountmarket,
			&i.Fullname,
			&i.Tradesidetype,
			&i.Ispalisade,
			&i.Lastcheck,
			&i.Support,
			&i.Resistance,
			&i.Rangevalue,
			&i.Rangepercent,
			&i.Avgprice,
			&i.Volatility,
			&i.Maxdrawdown,
			&i.Maxrise,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountLogsByCoin = `-- name: GetCountLogsByCoin :one
SELECT COUNT(*) FROM logs
WHERE coinFirst = $1 AND coinSecond = $2 LIMIT 1
`

type GetCountLogsByCoinParams struct {
	Coinfirst  string
	Coinsecond string
}

func (q *Queries) GetCountLogsByCoin(ctx context.Context, arg GetCountLogsByCoinParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountLogsByCoin, arg.Coinfirst, arg.Coinsecond)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLastTradeId = `-- name: GetLastTradeId :one
SELECT MAX(id) FROM trade_log
`

func (q *Queries) GetLastTradeId(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getLastTradeId)
	var max interface{}
	err := row.Scan(&max)
	return max, err
}

const getOpenOrders = `-- name: GetOpenOrders :many
SELECT id, open_date, deal_date, close_date, cancel_date, open_balance, close_balance, symbol, buy_price, sell_price, amount, orderid, orderid_sell, uplevel, downlevel FROM trade_log
WHERE 
    close_date IS NULL
    AND cancel_date IS NULL
`

func (q *Queries) GetOpenOrders(ctx context.Context) ([]TradeLog, error) {
	rows, err := q.db.Query(ctx, getOpenOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TradeLog
	for rows.Next() {
		var i TradeLog
		if err := rows.Scan(
			&i.ID,
			&i.OpenDate,
			&i.DealDate,
			&i.CloseDate,
			&i.CancelDate,
			&i.OpenBalance,
			&i.CloseBalance,
			&i.Symbol,
			&i.BuyPrice,
			&i.SellPrice,
			&i.Amount,
			&i.Orderid,
			&i.OrderidSell,
			&i.Uplevel,
			&i.Downlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveCoin = `-- name: SaveCoin :one
INSERT INTO
    coins (
    date,
    symbol,
    status,
    baseAsset,
    baseAssetPrecision,
    quoteAsset,
    quotePrecision,
    quoteAssetPrecision,
    baseCommissionPrecision,
    quoteCommissionPrecision,
    orderTypes,
    isSpotTradingAllowed,
    isMarginTradingAllowed,
    quoteAmountPrecision,
    baseSizePrecision,
    permissions,
    maxQuoteAmount,
    makerCommission,
    takerCommission,
    quoteAmountPrecisionMarket,
    maxQuoteAmountMarket,
    fullName,
    tradeSideType,
    isPalisade
)
VALUES (
           $1,
           $2,
           $3,
           $4,
           $5,
           $6,
           $7,
           $8,
           $9,
           $10,
           $11,
           $12,
           $13,
           $14,
           $15,
           $16,
           $17,
           $18,
           $19,
           $20,
           $21,
           $22,
           $23,
           $24
       )
    RETURNING id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade, lastcheck, support, resistance, rangevalue, rangepercent, avgprice, volatility, maxdrawdown, maxrise
`

type SaveCoinParams struct {
	Date                       time.Time
	Symbol                     string
	Status                     int
	Baseasset                  string
	Baseassetprecision         float64
	Quoteasset                 string
	Quoteprecision             int
	Quoteassetprecision        int
	Basecommissionprecision    int
	Quotecommissionprecision   int
	Ordertypes                 []string
	Isspottradingallowed       bool
	Ismargintradingallowed     bool
	Quoteamountprecision       float64
	Basesizeprecision          float64
	Permissions                []string
	Maxquoteamount             int
	Makercommission            float64
	Takercommission            float64
	Quoteamountprecisionmarket float64
	Maxquoteamountmarket       int
	Fullname                   string
	Tradesidetype              int
	Ispalisade                 bool
}

func (q *Queries) SaveCoin(ctx context.Context, arg SaveCoinParams) (Coin, error) {
	row := q.db.QueryRow(ctx, saveCoin,
		arg.Date,
		arg.Symbol,
		arg.Status,
		arg.Baseasset,
		arg.Baseassetprecision,
		arg.Quoteasset,
		arg.Quoteprecision,
		arg.Quoteassetprecision,
		arg.Basecommissionprecision,
		arg.Quotecommissionprecision,
		arg.Ordertypes,
		arg.Isspottradingallowed,
		arg.Ismargintradingallowed,
		arg.Quoteamountprecision,
		arg.Basesizeprecision,
		arg.Permissions,
		arg.Maxquoteamount,
		arg.Makercommission,
		arg.Takercommission,
		arg.Quoteamountprecisionmarket,
		arg.Maxquoteamountmarket,
		arg.Fullname,
		arg.Tradesidetype,
		arg.Ispalisade,
	)
	var i Coin
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Symbol,
		&i.Status,
		&i.Baseasset,
		&i.Baseassetprecision,
		&i.Quoteasset,
		&i.Quoteprecision,
		&i.Quoteassetprecision,
		&i.Basecommissionprecision,
		&i.Quotecommissionprecision,
		&i.Ordertypes,
		&i.Isspottradingallowed,
		&i.Ismargintradingallowed,
		&i.Quoteamountprecision,
		&i.Basesizeprecision,
		&i.Permissions,
		&i.Maxquoteamount,
		&i.Makercommission,
		&i.Takercommission,
		&i.Quoteamountprecisionmarket,
		&i.Maxquoteamountmarket,
		&i.Fullname,
		&i.Tradesidetype,
		&i.Ispalisade,
		&i.Lastcheck,
		&i.Support,
		&i.Resistance,
		&i.Rangevalue,
		&i.Rangepercent,
		&i.Avgprice,
		&i.Volatility,
		&i.Maxdrawdown,
		&i.Maxrise,
	)
	return i, err
}

const saveTradeLog = `-- name: SaveTradeLog :one
INSERT INTO trade_log (
   open_date,
   open_balance,
   symbol,
   buy_price,
   amount,
   orderId,
   upLevel,
   downLevel
   )
   VALUES (
           $1,
           $2,
           $3,
           $4,
           $5,
           $6,
           $7,
           $8
   )
   RETURNING id, open_date, deal_date, close_date, cancel_date, open_balance, close_balance, symbol, buy_price, sell_price, amount, orderid, orderid_sell, uplevel, downlevel
`

type SaveTradeLogParams struct {
	OpenDate    time.Time
	OpenBalance float64
	Symbol      string
	BuyPrice    float64
	Amount      float64
	Orderid     string
	Uplevel     float64
	Downlevel   float64
}

func (q *Queries) SaveTradeLog(ctx context.Context, arg SaveTradeLogParams) (TradeLog, error) {
	row := q.db.QueryRow(ctx, saveTradeLog,
		arg.OpenDate,
		arg.OpenBalance,
		arg.Symbol,
		arg.BuyPrice,
		arg.Amount,
		arg.Orderid,
		arg.Uplevel,
		arg.Downlevel,
	)
	var i TradeLog
	err := row.Scan(
		&i.ID,
		&i.OpenDate,
		&i.DealDate,
		&i.CloseDate,
		&i.CancelDate,
		&i.OpenBalance,
		&i.CloseBalance,
		&i.Symbol,
		&i.BuyPrice,
		&i.SellPrice,
		&i.Amount,
		&i.Orderid,
		&i.OrderidSell,
		&i.Uplevel,
		&i.Downlevel,
	)
	return i, err
}

const updateCancelDateTradeLog = `-- name: UpdateCancelDateTradeLog :exec
UPDATE trade_log
SET cancel_date = $1
WHERE id = $2
`

type UpdateCancelDateTradeLogParams struct {
	CancelDate *time.Time
	ID         int
}

func (q *Queries) UpdateCancelDateTradeLog(ctx context.Context, arg UpdateCancelDateTradeLogParams) error {
	_, err := q.db.Exec(ctx, updateCancelDateTradeLog, arg.CancelDate, arg.ID)
	return err
}

const updateDealDateTradeLog = `-- name: UpdateDealDateTradeLog :exec
UPDATE trade_log
SET deal_date = $1
WHERE id = $2
`

type UpdateDealDateTradeLogParams struct {
	DealDate *time.Time
	ID       int
}

func (q *Queries) UpdateDealDateTradeLog(ctx context.Context, arg UpdateDealDateTradeLogParams) error {
	_, err := q.db.Exec(ctx, updateDealDateTradeLog, arg.DealDate, arg.ID)
	return err
}

const updateIsPalisade = `-- name: UpdateIsPalisade :exec
UPDATE coins
SET isPalisade = $1, lastCheck = $2
WHERE symbol = $3
`

type UpdateIsPalisadeParams struct {
	Ispalisade bool
	Lastcheck  *time.Time
	Symbol     string
}

func (q *Queries) UpdateIsPalisade(ctx context.Context, arg UpdateIsPalisadeParams) error {
	_, err := q.db.Exec(ctx, updateIsPalisade, arg.Ispalisade, arg.Lastcheck, arg.Symbol)
	return err
}

const updatePalisadeParams = `-- name: UpdatePalisadeParams :exec
UPDATE coins
SET support = $1, resistance = $2, rangeValue = $3, rangePercent = $4, avgPrice = $5, volatility = $6, maxDrawdown = $7, maxRise = $8
WHERE symbol = $9
`

type UpdatePalisadeParamsParams struct {
	Support      *float64
	Resistance   *float64
	Rangevalue   *float64
	Rangepercent *float64
	Avgprice     *float64
	Volatility   *float64
	Maxdrawdown  *float64
	Maxrise      *float64
	Symbol       string
}

func (q *Queries) UpdatePalisadeParams(ctx context.Context, arg UpdatePalisadeParamsParams) error {
	_, err := q.db.Exec(ctx, updatePalisadeParams,
		arg.Support,
		arg.Resistance,
		arg.Rangevalue,
		arg.Rangepercent,
		arg.Avgprice,
		arg.Volatility,
		arg.Maxdrawdown,
		arg.Maxrise,
		arg.Symbol,
	)
	return err
}

const updateSellOrderIdTradeLog = `-- name: UpdateSellOrderIdTradeLog :exec
UPDATE trade_log
SET orderId_sell = $1
WHERE id = $2
`

type UpdateSellOrderIdTradeLogParams struct {
	OrderidSell *string
	ID          int
}

func (q *Queries) UpdateSellOrderIdTradeLog(ctx context.Context, arg UpdateSellOrderIdTradeLogParams) error {
	_, err := q.db.Exec(ctx, updateSellOrderIdTradeLog, arg.OrderidSell, arg.ID)
	return err
}

const updateSuccesTradeLog = `-- name: UpdateSuccesTradeLog :exec
UPDATE trade_log
SET close_date = $1, close_balance = $2, sell_price = $3
WHERE id = $4
`

type UpdateSuccesTradeLogParams struct {
	CloseDate    *time.Time
	CloseBalance *float64
	SellPrice    *float64
	ID           int
}

func (q *Queries) UpdateSuccesTradeLog(ctx context.Context, arg UpdateSuccesTradeLogParams) error {
	_, err := q.db.Exec(ctx, updateSuccesTradeLog,
		arg.CloseDate,
		arg.CloseBalance,
		arg.SellPrice,
		arg.ID,
	)
	return err
}
