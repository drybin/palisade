// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package palisade_database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCoinInfo = `-- name: GetCoinInfo :one
SELECT id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade, lastcheck, support, resistance, rangevalue, rangepercent, avgprice, volatility, maxdrawdown, maxrise FROM coins
WHERE symbol = $1 LIMIT 1
`

func (q *Queries) GetCoinInfo(ctx context.Context, symbol string) (Coin, error) {
	row := q.db.QueryRow(ctx, getCoinInfo, symbol)
	var i Coin
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Symbol,
		&i.Status,
		&i.Baseasset,
		&i.Baseassetprecision,
		&i.Quoteasset,
		&i.Quoteprecision,
		&i.Quoteassetprecision,
		&i.Basecommissionprecision,
		&i.Quotecommissionprecision,
		&i.Ordertypes,
		&i.Isspottradingallowed,
		&i.Ismargintradingallowed,
		&i.Quoteamountprecision,
		&i.Basesizeprecision,
		&i.Permissions,
		&i.Maxquoteamount,
		&i.Makercommission,
		&i.Takercommission,
		&i.Quoteamountprecisionmarket,
		&i.Maxquoteamountmarket,
		&i.Fullname,
		&i.Tradesidetype,
		&i.Ispalisade,
		&i.Lastcheck,
		&i.Support,
		&i.Resistance,
		&i.Rangevalue,
		&i.Rangepercent,
		&i.Avgprice,
		&i.Volatility,
		&i.Maxdrawdown,
		&i.Maxrise,
	)
	return i, err
}

const getCoinState = `-- name: GetCoinState :one
SELECT id, date, account_balance, coinfirst, coinsecond, price, amount, state, orderid, uplevel, downlevel FROM state
WHERE coinFirst = $1 AND coinSecond = $2 LIMIT 1
`

type GetCoinStateParams struct {
	Coinfirst  string
	Coinsecond string
}

func (q *Queries) GetCoinState(ctx context.Context, arg GetCoinStateParams) (State, error) {
	row := q.db.QueryRow(ctx, getCoinState, arg.Coinfirst, arg.Coinsecond)
	var i State
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.AccountBalance,
		&i.Coinfirst,
		&i.Coinsecond,
		&i.Price,
		&i.Amount,
		&i.State,
		&i.Orderid,
		&i.Uplevel,
		&i.Downlevel,
	)
	return i, err
}

const getCoins = `-- name: GetCoins :many
SELECT id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade, lastcheck, support, resistance, rangevalue, rangepercent, avgprice, volatility, maxdrawdown, maxrise FROM coins
WHERE 
    ($3::boolean IS NULL OR isSpotTradingAllowed = $3)
    AND ($4::boolean IS NULL OR isPalisade = $4)
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetCoinsParams struct {
	Limit   int32
	Offset  int32
	Column3 bool
	Column4 bool
}

func (q *Queries) GetCoins(ctx context.Context, arg GetCoinsParams) ([]Coin, error) {
	rows, err := q.db.Query(ctx, getCoins,
		arg.Limit,
		arg.Offset,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Coin
	for rows.Next() {
		var i Coin
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Symbol,
			&i.Status,
			&i.Baseasset,
			&i.Baseassetprecision,
			&i.Quoteasset,
			&i.Quoteprecision,
			&i.Quoteassetprecision,
			&i.Basecommissionprecision,
			&i.Quotecommissionprecision,
			&i.Ordertypes,
			&i.Isspottradingallowed,
			&i.Ismargintradingallowed,
			&i.Quoteamountprecision,
			&i.Basesizeprecision,
			&i.Permissions,
			&i.Maxquoteamount,
			&i.Makercommission,
			&i.Takercommission,
			&i.Quoteamountprecisionmarket,
			&i.Maxquoteamountmarket,
			&i.Fullname,
			&i.Tradesidetype,
			&i.Ispalisade,
			&i.Lastcheck,
			&i.Support,
			&i.Resistance,
			&i.Rangevalue,
			&i.Rangepercent,
			&i.Avgprice,
			&i.Volatility,
			&i.Maxdrawdown,
			&i.Maxrise,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountLogsByCoin = `-- name: GetCountLogsByCoin :one
SELECT COUNT(*) FROM logs
WHERE coinFirst = $1 AND coinSecond = $2 LIMIT 1
`

type GetCountLogsByCoinParams struct {
	Coinfirst  string
	Coinsecond string
}

func (q *Queries) GetCountLogsByCoin(ctx context.Context, arg GetCountLogsByCoinParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountLogsByCoin, arg.Coinfirst, arg.Coinsecond)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const saveCoin = `-- name: SaveCoin :one
INSERT INTO
    coins (
    date,
    symbol,
    status,
    baseAsset,
    baseAssetPrecision,
    quoteAsset,
    quotePrecision,
    quoteAssetPrecision,
    baseCommissionPrecision,
    quoteCommissionPrecision,
    orderTypes,
    isSpotTradingAllowed,
    isMarginTradingAllowed,
    quoteAmountPrecision,
    baseSizePrecision,
    permissions,
    maxQuoteAmount,
    makerCommission,
    takerCommission,
    quoteAmountPrecisionMarket,
    maxQuoteAmountMarket,
    fullName,
    tradeSideType,
    isPalisade
)
VALUES (
           $1,
           $2,
           $3,
           $4,
           $5,
           $6,
           $7,
           $8,
           $9,
           $10,
           $11,
           $12,
           $13,
           $14,
           $15,
           $16,
           $17,
           $18,
           $19,
           $20,
           $21,
           $22,
           $23,
           $24
       )
    RETURNING id, date, symbol, status, baseasset, baseassetprecision, quoteasset, quoteprecision, quoteassetprecision, basecommissionprecision, quotecommissionprecision, ordertypes, isspottradingallowed, ismargintradingallowed, quoteamountprecision, basesizeprecision, permissions, maxquoteamount, makercommission, takercommission, quoteamountprecisionmarket, maxquoteamountmarket, fullname, tradesidetype, ispalisade, lastcheck, support, resistance, rangevalue, rangepercent, avgprice, volatility, maxdrawdown, maxrise
`

type SaveCoinParams struct {
	Date                       time.Time
	Symbol                     string
	Status                     int
	Baseasset                  string
	Baseassetprecision         float64
	Quoteasset                 string
	Quoteprecision             int
	Quoteassetprecision        int
	Basecommissionprecision    int
	Quotecommissionprecision   int
	Ordertypes                 []string
	Isspottradingallowed       bool
	Ismargintradingallowed     bool
	Quoteamountprecision       float64
	Basesizeprecision          float64
	Permissions                []string
	Maxquoteamount             int
	Makercommission            float64
	Takercommission            float64
	Quoteamountprecisionmarket float64
	Maxquoteamountmarket       int
	Fullname                   string
	Tradesidetype              int
	Ispalisade                 bool
}

func (q *Queries) SaveCoin(ctx context.Context, arg SaveCoinParams) (Coin, error) {
	row := q.db.QueryRow(ctx, saveCoin,
		arg.Date,
		arg.Symbol,
		arg.Status,
		arg.Baseasset,
		arg.Baseassetprecision,
		arg.Quoteasset,
		arg.Quoteprecision,
		arg.Quoteassetprecision,
		arg.Basecommissionprecision,
		arg.Quotecommissionprecision,
		arg.Ordertypes,
		arg.Isspottradingallowed,
		arg.Ismargintradingallowed,
		arg.Quoteamountprecision,
		arg.Basesizeprecision,
		arg.Permissions,
		arg.Maxquoteamount,
		arg.Makercommission,
		arg.Takercommission,
		arg.Quoteamountprecisionmarket,
		arg.Maxquoteamountmarket,
		arg.Fullname,
		arg.Tradesidetype,
		arg.Ispalisade,
	)
	var i Coin
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Symbol,
		&i.Status,
		&i.Baseasset,
		&i.Baseassetprecision,
		&i.Quoteasset,
		&i.Quoteprecision,
		&i.Quoteassetprecision,
		&i.Basecommissionprecision,
		&i.Quotecommissionprecision,
		&i.Ordertypes,
		&i.Isspottradingallowed,
		&i.Ismargintradingallowed,
		&i.Quoteamountprecision,
		&i.Basesizeprecision,
		&i.Permissions,
		&i.Maxquoteamount,
		&i.Makercommission,
		&i.Takercommission,
		&i.Quoteamountprecisionmarket,
		&i.Maxquoteamountmarket,
		&i.Fullname,
		&i.Tradesidetype,
		&i.Ispalisade,
		&i.Lastcheck,
		&i.Support,
		&i.Resistance,
		&i.Rangevalue,
		&i.Rangepercent,
		&i.Avgprice,
		&i.Volatility,
		&i.Maxdrawdown,
		&i.Maxrise,
	)
	return i, err
}

const updateIsPalisade = `-- name: UpdateIsPalisade :exec
UPDATE coins
SET isPalisade = $1, lastCheck = $2
WHERE symbol = $3
`

type UpdateIsPalisadeParams struct {
	Ispalisade bool
	Lastcheck  *time.Time
	Symbol     string
}

func (q *Queries) UpdateIsPalisade(ctx context.Context, arg UpdateIsPalisadeParams) error {
	_, err := q.db.Exec(ctx, updateIsPalisade, arg.Ispalisade, arg.Lastcheck, arg.Symbol)
	return err
}

const updatePalisadeParams = `-- name: UpdatePalisadeParams :exec
UPDATE coins
SET support = $1, resistance = $2, rangeValue = $3, rangePercent = $4, avgPrice = $5, volatility = $6, maxDrawdown = $7, maxRise = $8
WHERE symbol = $9
`

type UpdatePalisadeParamsParams struct {
	Support      pgtype.Float8
	Resistance   pgtype.Float8
	Rangevalue   pgtype.Float8
	Rangepercent pgtype.Float8
	Avgprice     pgtype.Float8
	Volatility   pgtype.Float8
	Maxdrawdown  pgtype.Float8
	Maxrise      pgtype.Float8
	Symbol       string
}

func (q *Queries) UpdatePalisadeParams(ctx context.Context, arg UpdatePalisadeParamsParams) error {
	_, err := q.db.Exec(ctx, updatePalisadeParams,
		arg.Support,
		arg.Resistance,
		arg.Rangevalue,
		arg.Rangepercent,
		arg.Avgprice,
		arg.Volatility,
		arg.Maxdrawdown,
		arg.Maxrise,
		arg.Symbol,
	)
	return err
}
